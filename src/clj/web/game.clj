(ns web.game
  (:require
    [cheshire.core :as json]
    [clj-time.core :as t]
    [clojure.stacktrace :as stacktrace]
    [crypto.password.bcrypt :as bcrypt]
    [game.core :as core]
    [game.core.diffs :refer [public-diffs public-states]]
    [game.main :as main]
    [jinteki.utils :refer [side-from-str]]
    [web.lobby :as lobby]
    [web.stats :as stats]
    [web.ws :as ws]))

(defn send-state-diffs!
  "Sends diffs generated by public-diffs to all connected clients."
  [{:keys [gameid players spectators]}
   {:keys [runner-diff corp-diff spect-diff]}]
  (doseq [{:keys [uid side]} players]
    (ws/broadcast-to! [uid] :netrunner/diff (json/generate-string {:gameid gameid
                                                                   :diff (if (= side "Corp")
                                                                           corp-diff
                                                                           runner-diff)})))
  (ws/broadcast-to! (keep :uid spectators)
                    :netrunner/diff
                    (json/generate-string {:gameid gameid
                                           :diff spect-diff})))

(defn send-state!
  "Sends full states generated by public-states to either the client specified or all connected clients."
  ([event
    {:keys [players]}
    {:keys [runner-state corp-state spect-state]}
    uid]
   (let [player (some #(= (:uid %) uid) players)]
     (ws/broadcast-to! [uid] event (json/generate-string (if player
                                                           (if (= (:side player) "Corp")
                                                             corp-state
                                                             runner-state)
                                                           spect-state)))))

  ([event
    {:keys [players spectators]}
    {:keys [runner-state corp-state spect-state]}]
   (doseq [{:keys [uid side]} players]
     (ws/broadcast-to! [uid] event (json/generate-string (if (= side "Corp")
                                                           corp-state
                                                           runner-state))))
   (ws/broadcast-to! (keep :uid spectators) event (json/generate-string spect-state))))

(defn swap-and-send-diffs!
  "Updates the old-states atom with the new game state, then sends a :netrunner/diff
  message to game clients."
  [{:keys [gameid state] :as game}]
  (when (and state @state)
    (let [old-state (get @lobby/old-states gameid)
          diffs (public-diffs old-state state)]
      (swap! state update :history conj (:hist-diff diffs))
      (swap! lobby/old-states assoc gameid @state)
      (send-state-diffs! game diffs))))

(defn- active-game?
  [gameid-str uid]
  (if (nil? gameid-str)
    false
    (try
      (let [gameid (java.util.UUID/fromString gameid-str)
            game-from-gameid (lobby/game-for-id gameid)
            game-from-uid (lobby/game-for-client uid)]
        (and game-from-uid
             game-from-gameid
             (= (:gameid game-from-uid) (:gameid game-from-gameid))))
      (catch Exception _ false))))

(defn- is-starter-deck?
  [player]
  (let [id (get-in player [:deck :identity :title])
        card-cnt (reduce + (map :qty (get-in player [:deck :cards])))]
    (or (and (= id "The Syndicate: Profit over Principle")
             (= card-cnt 34))
        (and (= id "The Catalyst: Convention Breaker")
             (= card-cnt 30)))))

(defn- check-for-starter-decks
  "Starter Decks can require 6 or 7 agenda points"
  [game]
  (if (and (= (:format game) "system-gateway")
           (every? is-starter-deck? (:players game)))
    (do
      (swap! (:state game) assoc-in [:runner :agenda-point-req] 6)
      (swap! (:state game) assoc-in [:corp :agenda-point-req] 6)
      game)
    game))

(defmethod ws/-msg-handler :netrunner/start
  [{{db :system/db} :ring-req
    uid :uid}]
  (when-let [{:keys [players gameid started] :as game} (lobby/game-for-client uid)]
    (when (and (lobby/first-player? uid game)
               (not started))
      (let [strip-deck (fn [player] (-> player
                                        (update :deck select-keys [:_id :identity :name :hash])
                                        (update-in [:deck :identity] select-keys [:title :faction])))
            stripped-players (mapv strip-deck players)
            start-date (t/now)
            game (as-> game g
                   (assoc g :started true
                          :original-players stripped-players
                          :ending-players stripped-players
                          :start-date (java.util.Date.)
                          :last-update start-date
                          :last-update-only-actions start-date
                          :state (core/init-game g))
                   (check-for-starter-decks g)
                   (update g :players #(mapv strip-deck %)))]
        (stats/game-started db game)
        (lobby/refresh-lobby gameid game)
        (swap! lobby/old-states assoc gameid @(:state game))
        (send-state! :netrunner/start game (public-states (:state game)))))))

(defmethod ws/-msg-handler :netrunner/leave
  [{{db :system/db
     {:keys [username]} :user} :ring-req
    uid :uid}]
  (let [{:keys [started gameid state]} (lobby/game-for-client uid)]
    (when (and started state)
      (lobby/remove-user db uid gameid)
      (when (lobby/game-for-id gameid)
        ; The game will not exist if this is the last player to leave.
        (main/handle-notification state (str username " has left the game."))
        (swap-and-send-diffs! (lobby/game-for-id gameid))))))

(defmethod ws/-msg-handler :netrunner/rejoin
  [{{{:keys [_id] :as user} :user} :ring-req
    uid                      :uid
    {:keys [gameid]}               :?data}]
  (let [{:keys [original-players started players state] :as game} (lobby/game-for-id gameid)
        original-player (some #(if (= _id (get-in % [:user :_id])) % nil) original-players)]
    (when (and started
               (< (count (filter #(not= _id (get-in % [:user :_id])) players)) 2)
               original-player)
      (let [side (keyword (str (.toLowerCase (:side original-player)) "-state"))]
        (ws/broadcast-to! [uid] :games/diff {:diff {:update {gameid (lobby/game-lobby-view gameid game)}}})
        (ws/broadcast-to! [uid] :lobby/select {:gameid gameid
                                                     :started started
                                                     ; side works here because user cannot rejoin as a spectator
                                                     :state (json/generate-string (side (public-states (:state game))))})
        (lobby/join-game user uid gameid "Any Side")
        (main/handle-rejoin state user)
        (swap-and-send-diffs! (lobby/game-for-id gameid))))))

(defmethod ws/-msg-handler :netrunner/concede
  [{uid            :uid
    {:keys [gameid-str]} :?data}]
  (when (active-game? gameid-str uid)
    (let [gameid (java.util.UUID/fromString gameid-str)
          {:keys [players state] :as game} (lobby/game-for-id gameid)
          side (some #(when (= uid (:uid %)) (:side %)) players)]
      (when (lobby/player? uid game)
        (main/handle-concede state (side-from-str side))
        (swap-and-send-diffs! game)))))

(defmethod ws/-msg-handler :netrunner/mute-spectators
  [{{{:keys [username]} :user}      :ring-req
    uid                       :uid
    {:keys [gameid-str mute-state]} :?data}]
  (when (active-game? gameid-str uid)
    (let [gameid (java.util.UUID/fromString gameid-str)
          {:keys [state] :as game} (lobby/game-for-id gameid)
          message (if mute-state "muted" "unmuted")]
      (when (lobby/player? uid game)
        (lobby/refresh-lobby-assoc-in gameid [:mute-spectators] mute-state)
        (main/handle-notification state (str username " " message " spectators."))
        (swap-and-send-diffs! game)))))

(defmethod ws/-msg-handler :netrunner/action
  [{{user :user} :ring-req
    uid                           :uid
    {:keys [gameid-str command args]} :?data}]
  (when (active-game? gameid-str uid)
    (try
      (let [gameid (java.util.UUID/fromString gameid-str)
            {:keys [players state] :as game} (lobby/game-for-id gameid)
            side (some #(when (= uid (:uid %)) (:side %)) players)
            spectator (lobby/spectator? uid game)]
        (if (and state side)
            (let [old-state @state]
              (try
                (main/handle-action user command state (side-from-str side) args)
                (lobby/refresh-lobby-assoc-in gameid [:last-update] (t/now))
                (swap-and-send-diffs! game)
                (catch Exception e
                  (reset! state old-state)
                  (throw e))))
            (when-not spectator
              (println "handle-game-action unknown state or side")
              (println "\tGameID:" gameid)
              (println "\tGameID by ClientID:" (:gameid (lobby/game-for-client uid)))
              (println "\tClientID:" uid)
              (println "\tSide:" side)
              (println "\tPlayers:" (map #(select-keys % [:uid :side]) players))
              (println "\tSpectators" (map #(select-keys % [:uid]) (:spectators game)))
              (println "\tCommand:" command)
              (println "\tArgs:" args "\n"))))
      (catch Exception e
        (ws/broadcast-to! [uid] :netrunner/error nil)
        (println (str "Caught exception"
                      "\nException Data: " (or (ex-data e) (.getMessage e))
                      "\nCommand: " command
                      "\nGameId: " gameid-str
                      "\nStacktrace: " (with-out-str (stacktrace/print-stack-trace e 100))))))))

(defmethod ws/-msg-handler :netrunner/resync
  [{uid :uid
    {:keys [gameid-str]} :?data}]
  (when (active-game? gameid-str uid)
    (let [gameid (java.util.UUID/fromString gameid-str)
          {:keys [players state] :as game} (lobby/game-for-id gameid)]
      (if state
          (send-state! :netrunner/state game (public-states (:state game)) uid)
          (do (println "resync request unknown state")
              (println "\tGameID:" gameid)
              (println "\tGameID by ClientID:" (:gameid (lobby/game-for-client uid)))
              (println "\tClientID:" uid)
              (println "\tPlayers:" (map #(select-keys % [:uid :side]) players))
              (println "\tSpectators" (map #(select-keys % [:uid]) (:spectators game))))))))

(defmethod ws/-msg-handler :lobby/watch
  ;; Handles a watch command when a game has started.
  [{{db :system/db
     {:keys [username] :as user} :user} :ring-req
    uid :uid
    {:keys [gameid password]} :?data
    reply-fn :?reply-fn :as arg}]
  (lobby/handle-lobby-watch arg)
  (if-let [{game-password :password state :state started :started :as game}
           (lobby/game-for-id gameid)]
    (when (and user game (lobby/allowed-in-game db game user) state @state)
      (if-not started
        false ; don't handle this message, let lobby/handle-game-watch.
        (if (and (not (lobby/already-in-game? user game))
                 (or (empty? game-password)
                     (bcrypt/check password game-password)))
          (let [{:keys [spect-state]} (public-states state)]
            ;; Add as a spectator, inform the client that this is the active game,
            ;; Send existing state to spectator
            ;; add a chat message, then send diff state to all players.
            (ws/broadcast-to! [uid] :lobby/select {:gameid gameid
                                                         :started started
                                                         :state (json/generate-string spect-state)})
            (ws/broadcast-to! [uid] :games/diff {:diff {:update {gameid (lobby/game-lobby-view gameid game)}}})
            (lobby/spectate-game user uid gameid)
            (main/handle-notification state (str username " joined the game as a spectator."))
            (swap-and-send-diffs! (lobby/game-for-id gameid))
            (when reply-fn
              (reply-fn 200)))
          (when reply-fn
            (reply-fn 403)))))
    (when reply-fn
      (reply-fn 404))))

(defmethod ws/-msg-handler :netrunner/say
  [{{user :user} :ring-req
    uid :uid
    {:keys [gameid-str msg]} :?data}]
  (when (active-game? gameid-str uid)
    (let [gameid (java.util.UUID/fromString gameid-str)
          {:keys [state mute-spectators] :as game} (lobby/game-for-id gameid)
          {:keys [side]} (lobby/player? uid game)]
      (if (and state side user)
        (do (main/handle-say state (side-from-str side) user msg)
            (swap-and-send-diffs! game))
        (when (and (lobby/spectator? uid game) (not mute-spectators))
          (main/handle-say state :spectator user msg)
          (lobby/refresh-lobby-assoc-in gameid [:last-update] (t/now))
          (try
            (swap-and-send-diffs! game)
            (catch Exception ex
              (println (str "handle-game-say exception:" (.getMessage ex) "\n")))))))))

(defmethod ws/-msg-handler :netrunner/typing
  [{uid :uid
    {:keys [gameid-str typing]} :?data}]
  (when (active-game? gameid-str uid)
    (let [gameid (java.util.UUID/fromString gameid-str)
          {:keys [state] :as game} (lobby/game-for-id gameid)
          {:keys [side user]} (lobby/player? uid game)]
      (when (and state side user)
        (main/handle-typing state (side-from-str side) user typing)
        (try
          (swap-and-send-diffs! game)
          (catch Exception ex
            (println (str "handle-game-typing exception:" (.getMessage ex) "\n"))))))))

(defmethod ws/-msg-handler :chsk/uidport-close
  [{{db :system/db
     {:keys [username]} :user} :ring-req
    uid :uid}]
  (when-let [{:keys [gameid state]} (lobby/game-for-client uid)]
    (lobby/remove-user db uid gameid)
    (when-let [game (lobby/game-for-id gameid)]
      ; The game will not exist if this is the last player to leave.
      (main/handle-notification state (str username " has disconnected."))
      (swap-and-send-diffs! game))))
